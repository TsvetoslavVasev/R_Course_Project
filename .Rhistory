cbind(round(prop.table(table(apps$Content.Rating))*100, 2))
#Rating
cbind(round(prop.table(table(apps$Rating))*100, 2))
#Installs
cbind(round(prop.table(table(apps$Installs))*100, 2))
#Android.version
cbind(round(prop.table(table(apps$Android.Ver))*100, 2))
#Summaries
summary(apps$Rating)
summary(apps$Installs)
summary(apps$Type)
summary(apps$Content.Rating)
summary(apps$Last.Updated)
#първите 10 наблюдения
head(apps,10)
#Всички приложения, които не са безплатни и техните reviews ----
apps <- apps[is.na(apps$Type)==FALSE, ]
table(apps$Type)
table(apps$Type)["Free"]
table(apps$Type)["Paid"]
#Всички приложения с Rating != NA и Sentiment != NA
apps <- apps[is.na(apps$Rating)==FALSE, ]
appsReview <- appsReview[is.na(appsReview$Sentiment)==FALSE,]
appsReview <- appsReview[is.na(appsReview$Sentiment_Polarity)==FALSE, ]
#таблици ----
prop.table(table(apps$Category))["ART_AND_DESIGN"]
table(apps$Category)
table(apps$Category)[which(apps$Category.count>100)]
library(scales)
ggplot(appset, aes(x=Reviews, y=Rating)) +
scale_x_continuous(trans='log10', labels=comma) +
geom_point(aes(col=Type)) +
labs(title="Android App Ratings vs Number of Reviews", subtitle="Google Playstore Dataset", y="Rating from 1 to 5 stars", x="Number of Reviews") +
theme_linedraw()
ggplot(apps, aes(x=Reviews, y=Rating)) +
scale_x_continuous(trans='log10', labels=comma) +
geom_point(aes(col=Type)) +
labs(title="Android App Ratings vs Number of Reviews", subtitle="Google Playstore Dataset", y="Rating from 1 to 5 stars", x="Number of Reviews") +
theme_linedraw()
ggplot(apps, aes(x=Reviews, y=Rating)) +
scale_x_continuous(trans='log10', labels=comma) +
geom_point(aes(col=Type)) +
labs(title="Android App Ratings vs Number of Reviews", subtitle="Google Playstore Dataset", y="Rating from 1 to 5 stars", x="Number of Reviews") +
theme_linedraw()
#pie chart и честотна таблица за апликациите по категории
pie(table(apps$Category))
#таблици ----
prop.table(table(apps$Category))["ART_AND_DESIGN"]
table(apps$Category)
#забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes
prop.table(table(apps$Category))["Dating"]
#забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes
prop.table(table(apps$Category))["Dating"]
#забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes
prop.table(table(apps$Category))["Dating"]
#забелязваме че има най-много приложения от категории Datin,Education,Health_And_Fitnes
prop.table(table(apps$Category))["ART_AND_DESIGN"]
#таблици ----
table(apps$Category)
#забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes
prop.table(table(apps$Category))
table(apps$Category)[which >100]
#таблици ----
table(apps$Category)
table(apps$Category)[which >100]
table(length(apps$Category)>100)
#забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes
table(apps$Category[length(apps$Category)>100])
#забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes
table(apps$Category[length(apps$Category)>100])
table(length(apps$Category)>100)
#Забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes,Entertainment и Finance
pie(prop.table(table(apps$Category)))
#Забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes,Entertainment и Finance
pie(prop.table(table(apps$Category)))
#Забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes,Entertainment и Finance
table(apps[count(apps$Category)>100])
#Забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes,Entertainment и Finance
table(apps[count(apps$Category)>100,])
#Забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes,Entertainment и Finance
table(apps$Category[count(apps$Category)>100,])
#Забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes,Entertainment и Finance
table(apps$Category)[apps$Category.count > 90]
#Забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes,Entertainment и Finance
table(apps$Category)[count(apps$Category)>100,]
pie(table(apps$Category[]))
pie(table(apps$Category)["DATING","HEALTH_AND_FITNES","EDUCATION","ENTERTAINMENT","FINANCE"])
#Забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes,Entertainment и Finance
table(apps$Category)["DATING","HEALTH_AND_FITNES","EDUCATION","ENTERTAINMENT","FINANCE"]
#Забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes,Entertainment и Finance
table(apps$Category)["DATING","HEALTH_AND_FITNES","EDUCATION","ENTERTAINMENT","FINANCE"]
#Забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes,Entertainment и Finance
table(apps$Category)["DATING"]
table(apps$Category)>80
#Забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes,Entertainment и Finance
pie(prop.table(table(apps$Category)>80))
#Забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes,Entertainment и Finance
pie(prop.table(table(apps$Category)))
>80
#Забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes,Entertainment и Finance
pie(prop.table(table(apps$Category)>80))
#Забелязваме че има най-много приложения от категории Dating,Education,Health_And_Fitnes,Entertainment и Finance
length(apps$Category)
mean(apps$Rating,na.rm = TRUE)#sreden rating
max(apps$Rating,na.rm = TRUE)#max rating
summary(apps$Rating)
#Summaries
summary(apps$Rating)
table(apps$Category)
sum(apps$Category=="ART_AND_DESIGN",as.numeric(apps$Reviews),na.rm=TRUE)
sum(apps$Category=="SPORTS",as.numeric(apps$Reviews),na.rm=TRUE)
sum(apps$Category=="GAME",as.numeric(apps$Reviews),na.rm=TRUE)
sum(apps$Category=="FAMILY",as.numeric(apps$Reviews),na.rm=TRUE)
sum(apps$Category=="TOOLS",as.numeric(apps$Reviews),na.rm=TRUE)
sum(apps$Category=="FINANCE",as.numeric(apps$Reviews),na.rm=TRUE)
boxplot(apps$Installs,
beside=TRUE,
main ="Downloads")
boxplot(apps$Installs,
beside=TRUE,
main ="Downloads",
horizontal=TRUE)
summary(apps$Installs)
ggplot(c, aes(x = Category, y = Count)) +
geom_bar(stat="identity", width=.5,  fill="firebrick4") +
labs(title = "Top10 Categories") +
# subtitle = "How many apps included in each category ?") +
theme(axis.text.x = element_text(angle=65, vjust=0.6))
ggplot(c, aes(x = Category, y = Count)) +
geom_bar(stat="identity", width=.5,  fill="firebrick4") +
labs(title = "Top10 Categories") +
# subtitle = "How many apps included in each category ?") +
theme(axis.text.x = element_text(angle=65, vjust=0.6))
c <- apps %>%
group_by(apps$Category) %>%
summarize(Count = n()) %>%
arrange(desc(Count))
c <- apps %>%
group_by(Category) %>%
summarize(Count = n()) %>%
arrange(desc(Count))
ggplot(apps$Category, aes(x = Category, y = Count)) +
geom_bar(stat="identity", width=.5,  fill="firebrick4") +
labs(title = "Top10 Categories") +
# subtitle = "How many apps included in each category ?") +
theme(axis.text.x = element_text(angle=65, vjust=0.6))
ggplot(apps, aes(x = Category, y = Count)) +
geom_bar(stat="identity", width=.5,  fill="firebrick4") +
labs(title = "Top10 Categories") +
# subtitle = "How many apps included in each category ?") +
theme(axis.text.x = element_text(angle=65, vjust=0.6))
c <- head(c, 10)
c<-tolower(apps$Category)
c <- dataset %>%
group_by(Category) %>%
summarize(Count = n()) %>%
arrange(desc(Count))
c <- apps %>%
group_by(Category) %>%
summarize(Count = n()) %>%
arrange(desc(Count))
c <- head(c, 10)
ggplot(c, aes(x = Category, y = Count)) +
geom_bar(stat="identity", width=.5,  fill="firebrick4") +
labs(title = "Top10 Categories") +
# subtitle = "How many apps included in each category ?") +
theme(axis.text.x = element_text(angle=65, vjust=0.6))
ggplot(apps, aes(x = Category, y = Count)) +
geom_bar(stat="identity", width=.5,  fill="firebrick4") +
labs(title = "Top10 Categories") +
# subtitle = "How many apps included in each category ?") +
theme(axis.text.x = element_text(angle=65, vjust=0.6))
barplot(table(apps$Category)>80)
library(scales)
#scales library for log values to be displayed as natural numbers
ggplot(appset, aes(x=Reviews, y=Rating)) +
scale_x_continuous(trans='log10', labels=comma) +
geom_point(aes(col=Type)) +
labs(title="Android App Ratings vs Number of Reviews", subtitle="Google Playstore Dataset", y="Rating from 1 to 5 stars", x="Number of Reviews") +
theme_linedraw()
library(scales)
#scales library for log values to be displayed as natural numbers
ggplot(apps, aes(x=Reviews, y=Rating)) +
scale_x_continuous(trans='log10', labels=comma) +
geom_point(aes(col=Type)) +
labs(title="Android App Ratings vs Number of Reviews", subtitle="Google Playstore Dataset", y="Rating from 1 to 5 stars", x="Number of Reviews") +
theme_linedraw()
#scales library for log values to be displayed as natural numbers
ggplot(apps, aes(x=Reviews, y=Rating)) +
geom_point(aes(col=Type)) +
labs(title="Android App Ratings vs Number of Reviews", subtitle="Google Playstore Dataset", y="Rating from 1 to 5 stars", x="Number of Reviews") +
theme_linedraw()
#Забелязваме, яе пожеяето безплатни приложения имат рейтинг между 4 и 5
boxplot(apps$Installs,
beside=TRUE,
main ="Downloads",
horizontal=TRUE)
#Ще анализираме връзкате меьд
ggplot(apps, aes(x=Reviews, y=Rating)) +
geom_point(aes(col=Type)) +
labs(title="Android App Ratings vs Number of Reviews", subtitle="Google Playstore Dataset", y="Rating from 1 to 5 stars", x="Number of Reviews") +
theme_linedraw()
cor(apps$Rating~apps$Reviews)
cor(apps$Rating,apps$Reviews)
View(apps)
cor(apps$Rating,as.numeric(apps$Reviews))
apps$Reviews
#честотна таблица и barplot за колонка Type
barplot(table(apps$Type),
beside=TRUE,
col = c("red","green"),
legend.text = TRUE,
main = "Type")
table(apps$Type)
barplot(table(apps$Type),
beside=TRUE,
col = c("red","green"),
legend.text = TRUE,
main = "Type")
#хистограма на цените на апликациите
hist(apps$Price,
main = "Price")
#хистограма на цените на апликациите
hist(apps$Price > 1,
main = "Price")
#хистограма на цените на апликациите
hist(apps$Price > 1,
main = "Price")
#хистограма на цените на апликациите
hist(as.numeric(apps$Price) > 1,
main = "Price")
#хистограма на цените на апликациите
paid <- apps$Price > 1
hist(paid,
main = "Price")
hist(as.numeric(paid),
main = "Price")
paid
#хистограма на цените на апликациите
hist(apps$Price,
main = "Price")
apps$Price[apps$Price>0]
paid<-apps$Price[apps$Price>0]
summary(paid)
hist(paid,
main = "Price")
?hist
cor(paid~apps$Installs)
cor(paid,apps$Installs)
cor(apps$Rating,as.numeric(apps$Reviews))
hist(paid,
main = "Price")
#Ще разгледаме само платените тъй като базплатните са значително повече и не можем да получим нова информация от тях
Paid<-apps$Price[apps$Price>0]
summary(paid)
summary(Paid)
hist(Paid,
main = "Price")
hist?
#piе и честотна таблица за Content.Rating
pie(table(apps$Content.Rating),
main="Content Rating")
?hist
hist(Paid,
main = "Price")
hist(Paid,
main = "Price of paid apps")
?hist
summary(Paid)
shapiro.test(Paid)
shapiro.test(Paid)
plot(paid)
qqnorm(paid)
qqline(Paid)
#
#piе и честотна таблица за Content.Rating
pie(table(apps$Content.Rating),
main="Content Rating")
table(apps$Content.Rating)
prop.table(table(apps$Content.Rating))
hist(apps$Last.Updated,
main = "Last updated",
col = "blue")
barplot(apps$Last.Updated>2016,
main = "Last updated",
col = "blue")
hist
hist(apps$Last.Updated,
main = "Last updated",
col = "blue")
hist(apps$Last.Updated,
main = "Last updated",
col = "blue")
#Oт графиката виждаме, че рейтинга на съдржанието на повечето приложения е подходящ за всички
barplot(apps$Last.Updated>2015)
#Oт графиката виждаме, че рейтинга на съдржанието на повечето приложения е подходящ за всички
barplot(apps$Last.Updated>2014)
#Oт графиката виждаме, че рейтинга на съдржанието на повечето приложения е подходящ за всички
hist(apps$Last.Updated,
main = "Last updated",
col = "blue")
shapiro.test(apps$Last.Updated)
#Ще разгледаме само платените тъй като базплатните са значително повече и не можем да получим нова информация от тях
Paid<-apps$Price[apps$Price>0]
summary(Paid)
#Oт графиката виждаме, че рейтинга на съдржанието на повечето приложения е подходящ за всички
hist(apps$Last.Updated,
main = "Last updated",
col = "blue")
curve(dexp(x, rate = apps$Last.Updated), from = 0, col = "red", add = TRUE)
ks.test(apps$Last.Updated)
ex <- rexp(10000, rate = 1.85)
ks.test(ex,apps$Last.Updated)
ks.test(apps$Last.Updated)
ex <- rexp(10000, rate = 1.85) # generate some exponential distribution
ks.test(exp,apps$Last.Updated)
ks.test(exp,apps$Last.Updated)
# estimate the parameters
lastUpdate <- apps(ex, "exponential")
ks.test(exp,lastUpdate)
# estimate the parameters
lastUpdate <- apps(ex, "exponential")
#Забелязваме, че повечето приложениш са последно обновени през 2018, както и че разпределението е експоненциално
wilcox.test(lastUpdated)
#Забелязваме, че повечето приложениш са последно обновени през 2018, както и че разпределението е експоненциално
wilcox.test(as.numeric(lastUpdated))
#Забелязваме, че повечето приложениш са последно обновени през 2018, както и че разпределението е експоненциално
wilcox.test(as.numeric(lastUpdated),conf.int = TRUE)
#Забелязваме, че повечето приложениш са последно обновени през 2018, както и че разпределението е експоненциално
wilcox.test(as.numeric(lastUpdated),conf.level = TRUE)
#Забелязваме, че повечето приложениш са последно обновени през 2018, както и че разпределението е експоненциално
wilcox.test(as.numeric(lastUpdated),conf.level = 0.95)
#Oт графиката виждаме, че рейтинга на съдржанието на повечето приложения е подходящ за всички
hist(apps$Last.Updated,
main = "Last updated",
col = "blue")
#Забелязваме, че повечето приложениш са последно обновени през 2018, както и че разпределението е експоненциално
wilcox.test(as.numeric(lastUpdated),conf.int =TRUE)
#най-високо оценено приложение за Dating ----
datingApps=apps[apps$Category == "DATING", ]
head(datingApps[datingApps$Rating == max(datingApps$Rating),],1)
#най-ниско оценено приложение за Dating ----
head(datingApps[datingApps$Rating == min(datingApps$Rating),],1)
#търсим приложение, което го няма и приложение, което го има
datingApps[grepl("Tinder", datingApps$App), ]
datingApps[grepl("Daddy", datingApps$App), ]
#Броят на игрите между 1 и 10 милиона изтегляния ----
#и извадка в графика на техния рейтинг
autoApps <-apps[apps$Category=="AUTO_AND_VEHICLES", ]
autoApps = autoApps[autoApps$Installs >= 1000000 | autoApps$Installs <= 5000000,]
hist(autoApps$Rating, main="Auto & Vehicles Rating", xlab="Rating", ylab="Count",col="purple")
#Oт графиката виждаме, че рейтинга на съдржанието на повечето приложения е подходящ за всички
hist(apps$Last.Updated,
main = "Last updated",
col = "blue")
#Oт графиката виждаме, че рейтинга на съдржанието на повечето приложения е подходящ за всички
hist(apps$Last.Updated,
main = "Last updated",
col = "purple")
#Хистограма и графика на плътността на размерите на всички приложения ----
#стойностите са конвертирани от string в numeric
hist(apps$Size, col="purple", xlab="Size of apps", main="Histogram of application sizes" )
#Хистограма и графика на плътността на размерите на всички приложения ----
#стойностите са конвертирани от string в numeric
sizesLowerThan100 <- apps$Size<101
hist(sizesLowerThan100, col="purple", xlab="Size of apps", main="Histogram of application sizes" )
hist(as.numeric(sizesLowerThan100), col="purple", xlab="Size of apps", main="Histogram of application sizes" )
#Хистограма и графика на плътността на размерите на всички приложения ----
#стойностите са конвертирани от string в numeric
hist(apps$Size, col="purple", xlab="Size of apps", main="Histogram of application sizes" )
plot(density(table(apps$Size)), col="purple")
shapiro.test(apps$Size)
wilcox.test(apps$Size)
wilcox.test(apps$Size,conf.int = TRUE)
t.test(Paid)
shapiro.test(apps$Rating)
hist(apps$Rating)
shapiro.test(apps$Rating)
qqplot(apps$Rating)
qqplot(apps$Rating)
qqline(apps$Rating)
qqline(apps$Rating)
hist(apps$Rating)
shapiro.test(apps$Rating)
qqline(apps$Rating)
qqnorm(apps$Rating)
qqline(apps$Rating)
t.test(Paid)
wilcox.test(apps$Rating,con.int = TRUE)
wilcox.test(apps$Rating,conf.int = TRUE)
#Забелязваме, че 95% от данните за рейтинга на приложенията имат доверител интервал
#Хистограма и графика на плътността на размерите на всички приложения ----
#стойностите са конвертирани от string в numeric
hist(apps$Size, col="purple", xlab="Size of apps", main="Histogram of application sizes" )
hist(autoApps$Rating, main="Auto & Vehicles Rating", xlab="Rating", ylab="Count",col="purple")
#Забелязваме, че повечето приложениш са последно обновени през 2018, както и че разпределението е експоненциално
wilcox.test(as.numeric(lastUpdated),conf.int =TRUE)
hist(autoApps$Rating, main="Auto & Vehicles Rating", xlab="Rating", ylab="Count",col="purple")
shapiro.test(autoApps)
shapiro.test(autoApps)
shapiro.test(as.numeric(autoApps)
shapiro.test(as.numeric(autoApps))
shapiro.test(as.numeric(autoApps))
shapiro.test(autoApps$Rating)
t.test(autoApps$Rating)
shapiro.test(autoApps$Rating)
t.test(autoApps$Rating)
#Ще разгледаме по-подбробно информацията за рейтинг на п всички риложенията
hist(apps$Rating)
shapiro.test(apps$Rating)
qqnorm(apps$Rating)
qqline(apps$Rating)
wilcox.test(apps$Rating,conf.int = TRUE)
qqline(apps$Rating,col = 'purple')
qqnorm(apps$Rating,col = 'pink')
qqline(apps$Rating,col = 'purple')
#Хистограма и графика на плътността на размерите на всички приложения ----
#стойностите са конвертирани от string в numeric
hist(apps$Size, col="purple", xlab="Size of apps", main="Histogram of application sizes" )
barplot(table(apps$Type,apps$Content.Rating),
legend.text = TRUE,
beside=TRUE,
col =c("green","red","blue","pink"),
main = "Type and Rating")
boxplot(apps$Rating~apps$Installs,
horizontal=TRUE)
hist(apps$Installs)
hist(apps$Installs,
main = "Installs",
col='purple')
shapiro.test(apps$Installs)
wilcox.test(apps$Installs,conf.int = TRUE)
cor(apps$Rating,apps$Installs)
barplot(table(apps$Type,apps$Content.Rating),
legend.text = TRUE,
beside=TRUE,
col =c("green","red","blue","pink"),
main = "Type and Rating")
#сравнение на непрекъсната и дискретна
boxplot(as.numeric(apps$Reviews) ,apps$Rating,
beside= TRUE,
notch =TRUE,
names=c("Reviews","Rating"),
main="Reviews and Rating")
#сравнение на непрекъсната и дискретна
boxplot(as.numeric(apps$Reviews) ,apps$Rating,
beside= TRUE,
notch =TRUE,
names=c("Reviews","Rating"),
main="Reviews and Rating")
boxplot(apps$Installs~apps$Type,
main="Installs and Type")
plot(apps$Last.Updated,apps$Installs)
plot(apps$Last.Updated~apps$Rating)
plot(apps$Last.Updated,apps$Installs)
plot(apps$Last.Updated~apps$Rating)
pie(table(appsReview$Sentiment),
main="Sentiment")
prop.table(table(appsReview$Sentiment))
plot(appsReview$Sentiment_Polarity,appsReview$Sentiment_Subjectivity)
plot(density(appsReview$Sentiment_Polarity,appsReview$Sentiment_Subjectivity),
col = "purple")
cor(appsReview$Sentiment_Polarity,appsReview$Sentiment_Subjectivity)
boxplot(apps$Price,apps$Rating, name="PRICE & RATING", names = c("Price", "Rating"))
plot(apps$Price,apps$Rating, name="PRICE & RATING")
cor(apps$Price,apps$Rating)
p
boxplot(apps$Price,apps$Rating, name="PRICE & RATING", names = c("Price", "Rating"))
#linear regression
#Ще изследваме връзката между reviews и броят изтегляния на приложенията
scatter.smooth(x=apps$Reviews, y=apps$Installs, main="Rating ~ Installs")  # scatterplot
#linear regression
#Ще изследваме връзката между reviews и броят изтегляния на приложенията
scatter.smooth(x=apps$Reviews, y=apps$Installs, main="Rating ~ Installs",col = ('purple','blue'))  # scatterplot
#linear regression
#Ще изследваме връзката между reviews и броят изтегляния на приложенията
scatter.smooth(x=apps$Reviews, y=apps$Installs, main="Rating ~ Installs",col = 'purple')  # scatterplot
#Графиката показва че по-високият брой ревюта на приложенията има общо с по-високия брой изтегляния
#Правим боксплот за да проверим за outliers
par(mfrow=c(1, 2))  # divide graph area in 2 columns
boxplot(as.numeric(apps$Reviews), main="Reviews")  # box plot for 'reviews'
boxplot(apps$Installs, main="Installs")  # box plot for 'installs'
#density plot
par(mfrow=c(1, 2))  # divide graph area in 2 columns
plot(density(as.numeric(apps$Reviews)), main="Density Plot: Reviews", ylab="Frequency")  # density plot for 'reviews'
polygon(density(as.numeric(apps$Reviews)), col="red")
plot(density(apps$Installs,na.rm=TRUE), main="Density Plot: Installs", ylab="Frequency")  # density plot for 'installs'
polygon(density(apps$Installs,na.rm=TRUE), col="red")
#corelation
apps <- apps[is.na(apps$Installs)==FALSE,]
cor(as.numeric(apps$Reviews), apps$Installs)
#Стойността на корелацията върви към 1, което означава че има връзка между ревютата и броя изтегляния в права пропорционалност
#linear model
linearMod <- lm(Reviews ~ Installs, data=apps)  # build linear regression model on full data
print(linearMod)
# зависимостта е Installs = Intercept + (β ∗ Reviews)
# Installs =  98946.3399 + (0.2327 * Reviews)
# Сега имаме линеен модел и направихме формула която да предсказва стойността на Installs ако имаме стойност на Reviews
# Но това не е достатъчно, за да можем да използваме този модел. Преди да го използваме трябва да разберем дали е статистически верен
summary(linearMod)
wilcox.test(apps$Size,conf.int = FALSE)
wilcox.test(apps$Size,conf.int = TRUE)
wilcox.test(apps$Size,conf.int = FALSE)
wilcox.test(apps$Size,conf.int = TRUE)
table(apps$Last.Updated)
table(apps$Last.Updated,apps$Type)
table(apps$Last.Updated~apps$Type)
t.test(autoApps$Rating)
shapiro.test(apps$Rating)
shapiro.test(Paid)
t.test(Paid)
table(apps$Last.Updated~apps$Type)
